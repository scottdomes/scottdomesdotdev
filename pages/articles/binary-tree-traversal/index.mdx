import ArticleLayout from "components/articles/ArticleLayout";

export const meta = {
  title: "Mental models of tree traversal",
  date: "2021-04-30T22:40:32.169Z",
  description:
    "Binary trees, N-ary trees, preorder, postorder, inorder, all of it",
};

A common programming interview question is to ask you to traverse a tree. The tree might look something like this, and you're asked to go from node to node in a certain order.

tree

There are many variations on this question. It could be an n-ary tree or a binary tree (we'll discuss the difference). You could have to go through the nodes from top to bottom, or left to right. You could have to do preorder traversal, or postorder, or inorder... oh my.

Don't fret. While there are many variations, with varying levels of difficulty, this question gets a lot simpler when you have the right mental model of how traversal should work. So that's the goal of this article: to give you a clear picture of how to approach traversal questions.

Note that we'll try to approach this in a language-agnostic way; you should be able to apply this mental model to any programming language. For the purpose of examples, I'll alternate between Ruby and JavaScript.

# Types of trees

There are two main types of trees you'll encounter: binary and n-ary.

## Binary trees

Binary trees are composed of nodes that can have zero, one, or two children. No more than two children per node.

Here's a simple example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" hidePlayButton />

Another one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6]}
  traversalMethod="preorder"
  hidePlayButton
/>

**Binary trees are made up of nodes with 0, 1, or 2 children.**

You may have also heard of binary _search_ trees, which are a subtype of binary trees, which specific rules for the order in which the numbers appear. You may see programming challenges involving binary search trees, but they're a little more complex, so we'll ignore them for now.

## N-ary trees

In a binary tree, each node is limited to two children. With an N-ary tree, you can have different maximum numbers of children, depending on _N_.

For example, a 3-ary tree (AKA ternary tree) means that each node can have a maximum of 3 children. A 156-ary tree means that each node can have up to 156 children.

Here's a N-ary tree where N is 4:

<BinaryTree
  tree={[1, null, 2, 3, 4, 5, null, 6, 7, null, 8]}
  treeType="nary"
  traversalMethod="preorder"
  hidePlayButton
/>

**N-ary trees are made up of nodes with up to N children.**

A binary tree is really just a specific type of N-ary tree: a 2-ary tree. But they're very common in interview questions, so it's good to talk about them. You may encounter challenges involving both binary and n-ary trees, but binary is the most popular type.

# Traversal

The basic definition of traversal is to visit each node in the tree once. How you do so, and in what order, depends on the question. Often, you'll be asked to keep track of each node you visited, in order, and give that as your solution.

There are several types of traversal. For this article, we're going to focus on the three most common: **preorder, inorder, and postorder.**

For each type, I'm going to explain how it works for a binary tree, and then show you the implementation. After we go through each type with the binary tree, I'll repeat the process with N-ary tree. Binary trees are easier to navigate and understand, so I think this will help you get the hang of it faster.

## Binary tree traversal

### Preorder traversal of a binary tree

Preorder traversal follows a simple process for visiting each node in the tree. Remember most challenges will ask you to return an array representing the order in which you visited the nodes; for each node we "visit", imagine pushing its value into an array, and then returning that.

Here's the process for preorder traversal:

1. Visit the first node (Node 1) in the tree, and push it into our output array
2. Visit the left child of Node 1 (Node 2), and push it into our output array
3. If Node 2 has a left child, we visit it, and push it into our output array; otherwise, we go to the right node of Node 1 (Node 3)

For each node, the process is: visit node, visit left child, visit right child.

This process is much easier to make sense of with a visualization. Let's start with a simple example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="preorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="preorder"
/>

### Implementing binary preorder traversal

All tree traversal solutions are pretty similar, so this section will be the longest one, but once you get the hang of it, the rest will make a lot more sense.

There are two main ways to solve this problem: through _recursion_ or through using a _stack_.

Let's start with recursion, and talk about what that means.

#### Solving binary preorder traversal with recursion

Recursion means calling the same function from within itself. Again, this is easier to understand with an example. Here's a code sample of our two functions, one of which is recursive:

```js
function traverse(node, output) {
  output.push(node.val);

  if (node.left) {
    traverse(node.left, output);
  }

  if (node.right) {
    traverse(node.right, output);
  }
}

function preorderTraverse(root) {
  const output: number[] = [];

  traverse(root, output);

  return output;
}
```

Let's walk through what's happening here, step by step.

First, in `preorderTraverse` (the second function):

1. We create an array called `output`. This is our solution, and will contain a list of nodes visited, in order.
2. We call our `traverse` function, passing in the root node and `output`. This function will visit nodes in order, and push each one into the `output` array.
3. We return the array.

In `traverse`, here's what happens:

1. We push the current node into the ouput array, which tracks the fact that we visited it.
2. If the node has a child to the left, we call `traverse` on it.
3. If that left child also has left children, that will spawn more calls to `traverse`. Eventually, though, that chain will end, and now we call `traverse` on the right child of the original node.

Here's another explanation, using the below tree as an example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" />

For this tree, the function calls will be:

1. `preorderTraverse` calls `traverse` with root node.
2. `traverse` push Node 1 into `output`, and calls `traverse` with its left child (Node 2).
3. `traverse` pushes Node 2 into `output`. Since Node 2 has no children, nothing else happens.
4. `traverse` calls `traverse` on Node 1's right child (Node 3).
5. `traverse` pushes Node 3 into `output`. Since Node 3 has no children, nothing else happens.
6. `preorderTraverse` returns `output`.

The function calls, in order, with the node arguments:

1. `preorderTraverse` is called with the root node (Node 1).
2. `traverse(Node1)` is called from `preorderTraverse`.
3. `traverse(Node2)` is called from `traverse(Node1)`.
4. `traverse(Node3)` is called from `traverse(Node1)`.

Let's do one more example.

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="preorder"
/>

Here are the function calls:

1. `preorderTraverse(Node1)`.
2. `traverse(Node1)` is called from `preorderTraverse(Node1)`.
3. `traverse(Node2)` is called from `traverse(Node1)`.
4. `traverse(Node4)` is called from `traverse(Node2)`
5. `traverse(Node5)` is called from `traverse(Node2)`
6. `traverse(Node3)` is called from `traverse(Node1)`.
7. `traverse(Node6)` is called from `traverse(Node3)`.
8. `traverse(Node7)` is called from `traverse(Node3)`.

One more way to look at it, in terms of nodes visited:

1. Node 1
2. Left child of Node 1
3. Left child of Node 2
4. Right child of Node 2
5. Right child of Node 1
6. Left child of Node 3
7. Right child of Node 3

Recursion can be confusing, but the end result should make sense: we visit each node, then its left child + its left child's children, then its right child + its right child's children.

The advantage of recursion is that it's short and easy to write, and may be a little more intuitive than the other method of traversal: iteration. But iteration is much more efficient, so let's take a look at how we'd implement it for preorder traversal.

#### Solving binary preorder traversal with iteration

The basis of iteration is that as we navigate the tree, we make a continually evolving list of nodes to visit.

The reason it is more efficient is that recursive function calls (calling functions within fuctions within functions) takes up space in memory (the "call stack"). If we're deep within a 1,000 node tree, we have a huge amount of context to store in memory for a given function call. More nodes, slower execution.

Iteration is more efficient because at any one time, we only store the next few nodes to visit. There's no recursion, so no filling up the call stack. Let's see it in practice to better understand how this works.

(By the way, the following code is literally powering the examples you see in this article.)

```js
function traverse(queue, output) {
  const current = queue.pop();

  output.push(current.val);

  if (current.right) {
    queue.push(current.right);
  }

  if (current.left) {
    queue.push(current.left);
  }
}

function preorderTraverse(node) {
  const queue = [node];
  const output = [];

  while (queue.length) {
    traverse(queue, output);
  }

  return output;
}
```

The structure here is similar. We have a `preorderTraverse`, which creates and returns an `output` array, containing a list of the nodes we visit, in order. But now, we have another array called `queue`.

The purpose of `queue` is to store the next few nodes we want to visit. Here's our approach:

1. As long as `queue` contains items, we call `traverse` over and over, passing the queue. At the start, it only contains the root node.
2. `traverse` takes the _last_ item out of the queue (I'll explain why in a second) and pushes it into `output`, marking it as visited. If that node has a right child, we push it into the queue. If it has a left child, we push it in as well.
3. The first execution of `traverse` ends, but since the queue now has _two_ items (the left and right child of the right node), it gets called again by the `while` loop.
4. This time, the last item in the queue is Node1's left child (since it was pushed second). We look for its children, and push them into the queue.
5. The process repeats until we've visited every item in the tree.

Let's look at what happens with the below tree:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" />

For this tree, the function calls will be:

1. `preorderTraverse` calls `traverse` with root node in queue.
2. `traverse` takes Node 1 out of the queue and pushes it into `output`, then pushes its right child (Node 3) and its left child (Node 2) into the queue.
3. Since the queue length is now 2, the `while` loop in `preorderTraverse` calls `traverse` again.
4. `traverse` takes Node 2 out of the queue and pushes it into `output`. Since it has no children, nothing else happens.
5. Since the queue length is 1, the `while` loop in `preorderTraverse` calls `traverse` again.
6. `traverse` takes Node 3 out of the queue and pushes it into `output`. Since it has no children, nothing else happens.
7. The queue length is now 0. `preorderTraverse` returns `output`.

Here's the function calls, showing what's happening in the queue:

1. `preorderTraverse` is called with the root node (Node 1).
2. `traverse([Node1])` is called from `preorderTraverse`.
3. `traverse([Node3, Node2])` is called from `preorderTraverse`.
4. `traverse([Node3])` is called from `preorderTraverse`.

A note on queue ordering: we actually want to visit the left child _first_, before the right, so we push it second and then use `pop` to take the last item from the queue each time. You could accomplish the same thing by pushing the left child in the queue first, then using `shift` instead of `pop` to take the first item in the array. But it's less efficient to use `shift`, since that requires moving every item in memory over one index.

Let's do one more example.

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="preorder"
/>

Here are the function calls:

1. `preorderTraverse(Node1)`.
2. `traverse([Node1])` is called from the `while` loop (all following calls are from the loop).
3. `traverse([Node3, Node2])` is called.
4. `traverse([Node3, Node5, Node4])` is called.
5. `traverse([Node3, Node5])` is called.
6. `traverse([Node3])` is called.
7. `traverse([Node7, Node6])` is called.
8. `traverse([Node7])` is called.

Which yields us the same order of nodes visited as recursion:

1. Node 1
2. Left child of Node 1
3. Left child of Node 2
4. Right child of Node 2
5. Right child of Node 1
6. Left child of Node 3
7. Right child of Node 3

Take your time to really understand both recursion and iteration in the above examples. The other forms of traversal are slightly different, but follow the same principles, so we'll start moving a bit faster.

### Inorder traversal of a binary tree

With inorder traversal, we visit the left child of the current node before we visit the node itself. Here are the differences between the two approaches:

**Preorder: Node, left child, right child**

**Inorder: Left child, node, right child**

Here's a simple example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="inorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="inorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="inorder"
/>

### Implementing binary inorder traversal

Again, we can take both a recursion and an interation approach. Again, iteration is more efficient, but recursion is simpler to impelement.

#### Solving binary inorder traversal with recursion

With recursion, changing from preorder to inorder is trivial. Let's see the two code samples side by side.

Here's preorder, as a refresher:

```js
function traverse(node, output) {
  output.push(node.val);

  if (node.left) {
    traverse(node.left, output);
  }

  if (node.right) {
    traverse(node.right, output);
  }
}

function preorderTraverse(root) {
  const output: number[] = [];

  traverse(root, output);

  return output;
}
```

And here's the new inorder implementation:

```js
function traverse(node, output) {
  if (node.left) {
    traverse(node.left, output);
  }

  output.push(node.val);

  if (node.right) {
    traverse(node.right, output);
  }
}

function inorderTraverse(root) {
  const output: number[] = [];

  traverse(root, output);

  return output;
}
```

How great is that? All we do is move `output.push(node.val);` down a couple of lines, to put the visitation of the left node first.

Let's do one example:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="inorder"
/>

Here are the function calls:

1. `inorderTraverse(Node1)`.
2. `traverse(Node1)` is called from `inorderTraverse(Node1)`.
3. `traverse(Node2)` is called from `traverse(Node1)`.
4. `traverse(Node4)` is called from `traverse(Node2)`
5. `traverse(Node4)` pushes Node 4 to output.
6. `traverse(Node2)` pushes Node 2 to output
7. `traverse(Node5)` is called from `traverse(Node2)`
8. `traverse(Node5)` pushes Node 5 to output.
9. `traverse(Node1)` pushes Node 1 to output.
10. `traverse(Node1)` calls `traverse(Node3)`.
11. `traverse(Node3)` calls `traverse(Node6)`.
12. `traverse(Node6)` pushes Node 6 to output.
13. `traverse(Node3)` pushes Node 3 to output.
14. `traverse(Node3)` calls `traverse(Node7)`.
15. `traverse(Node7)` pushes Node 7 to output.

The confusing part is that we fully explore a node's left subtree before pushing it to output. So we move up and down the call stack in a weird zigzagging way.

#### Solving binary inorder traversal with iteration

The iterative approach to inorder traversal is more complicated than the iterative approach to preorder. Instead of just relying on a `queue` to store the nodes we want to visit next, we also need to introduce a `currentNode` variable that helps us keep track of the current node.

```js
function traverse(currentNode, queue, output) {
  if (currentNode) {
    queue.push(currentNode);
    currentNode = currentNode.left;
  } else {
    const toVisit = queue.pop();
    output.push(toVisit.val);
    currentNode = toVisit.right;
  }
}

function inOrderTraverse(node) {
  const queue = [node];
  const output = [];
  let currentNode = node.left;

  while (currentNode || queue.length) {
    traverse(currentNode, queue, output);
  }

  return output;
}
```

Let's start with an example.

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" />

For this tree, the function calls will be:

1. `inorderTraverse` calls `traverse` with root node in queue and the `currentNode` as the Node 1's left child (Node 2).
2. Since there is a `currentNode`, `traverse` pushes Node 2 into the queue, and sets the `currentNode` to its left child... which is null. So `currentNode` is now null.
3. Since the queue length is now 2, the `while` loop in `inorderTraverse` calls `traverse` again.
4. Since there is NO `currentNode`, `traverse` removes Node 2 from the queue and pushes it into output. It then sets the `currentNode` to Node 2's right child... which is null. `currentNode` is null again.
4. Since the queue length is now 1, the `while` loop in `inorderTraverse` calls `traverse` again.
5. Since there is NO `currentNode`, `traverse` removes Node 1 from the queue and pushes it into output. It sets the `currentNode` to Node 1's right child, which is Node 3.
6. The queue length is now 0, but there is a `currentNode`, so the `while` loop in `inorderTraverse` calls `traverse` again.
7. Since there is a `currentNode`, `traverse` pushes Node 3 into the queue, and sets the `currentNode` to its left child... which is null. So `currentNode` is now null.
8. The queue length is now 1, so `inorderTraverse` calls `traverse` again.
9. Since there is NO `currentNode`, `traverse` removes Node 3 from the queue and pushes it into output. It sets the `currentNode` to Node 3's right child, which is null.
7. The queue length is now 0. `currentNode` is null. `inorderTraverse` returns `output`.

Here's the function calls, showing what's happening in `currentNode` (first argumemt) and the queue (second argument):

1. `inorderTraverse` is called with the root node (Node 1).
2. `traverse(Node2, [Node1])` is called from `inorderTraverse`.
3. `traverse(null, [Node1, Node2])` is called from `inorderTraverse`.
4. `traverse(null, [Node1])` is called from `inorderTraverse`.
5. `traverse(Node3, [])` is called from `inorderTraverse`.
6. `traverse(null, [Node3])` is called from `inorderTraverse`.

Let's do one more example.

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="inorder"
/>

Here are the function calls:

1. `inorderTraverse(Node1)`.
2. `traverse(Node2, [Node1])` is called from the `while` loop (all following calls are from the loop).
3. `traverse(Node4, [Node1, Node2])`
4. `traverse(null, [Node1, Node2, Node 4])`
5. `traverse(null, [Node1, Node2])`
6. `traverse(Node5, [Node1])`
7. `traverse(null, [Node1, Node5])`
8. `traverse(null, [Node1])`
9. `traverse(Node3, [])`
10. `traverse(Node6, [Node3])`
11. `traverse(null, [Node3, Node6])`
12. `traverse(null, [Node3])`
13. `traverse(Node7, [])`

You can see in the above that `Node` is in the queue from the very start, but it isn't removed & marked as visited until its entire left subtree is visited (which happens at step 8). That's inorder traversal in action.

As a side note, You may see solutions online that remove the need for the `current` variable by modifying the tree as we traverse it. That's a valid approach, but begs the question: what would you do if the tree was immutable?

Let's move on to the last form of traversal: postorder.

### Postorder traversal of a binary tree

Postorder is the reverse of preorder: in postorder, we visit all children before the parent.

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="postorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="postorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="postorder"
/>

#### Solving binary postorder traversal with recursion

Can you guess how we modify the below preorder traversal to be postorder?

```js
function traverse(node, output) {
  output.push(node.val);

  if (node.left) {
    traverse(node.left, output);
  }

  if (node.right) {
    traverse(node.right, output);
  }
}

function preorderTraverse(root) {
  const output: number[] = [];

  traverse(root, output);

  return output;
}
```

Here's the answer:

```js
function traverse(node, output) {
  if (node.left) {
    traverse(node.left, output);
  }

  if (node.right) {
    traverse(node.right, output);
  }

  output.push(node.val);
}

function postorderTraverse(root) {
  const output: number[] = [];

  traverse(root, output);

  return output;
}
```

Simple! We move the `output.push` until _after_ we've traversed both children (and their subtrees).

Let's do one example:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="postorder"
/>

Here are the function calls:

1. `postorderTraverse(Node1)`.
2. `traverse(Node1)` is called from `postorderTraverse(Node1)`.
3. `traverse(Node2)` is called from `traverse(Node1)`.
4. `traverse(Node4)` is called from `traverse(Node2)`
5. `traverse(Node4)` pushes Node 4 to output.
6. `traverse(Node5)` is called from `traverse(Node2)`
7. `traverse(Node5)` pushes Node 5 to output.
8. `traverse(Node2)` pushes Node 2 to output
9. `traverse(Node1)` calls `traverse(Node3)`.
10. `traverse(Node3)` calls `traverse(Node6)`.
11. `traverse(Node6)` pushes Node 6 to output.
12. `traverse(Node3)` calls `traverse(Node7)`.
13. `traverse(Node7)` pushes Node 7 to output.
14. `traverse(Node3)` pushes Node 3 to output.
15. `traverse(Node1)` pushes Node 1 to output.

With postorder traversal, the root node is the last one we visit.

#### Solving binary postorder traversal with iteration

# N-ary tree

## N-ary preorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="preorder"
/>

## N-ary inorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="inorder"
/>

<BinaryTree
  tree={[1, null, 2, 3, 4, 5, null, 6, 7]}
  treeType="nary"
  traversalMethod="inorder"
/>

## N-ary postorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="postorder"
/>

<BinaryTree
  tree={[1, null, 2, 3, 4, 5, null, 6, 7]}
  treeType="nary"
  traversalMethod="postorder"
/>

To implement this kind of traversal, the simplest approach is to use _recursion_.

Here's the code for applying this to a binary tree:

CODE

We print out the value of the node, and then visit its left child, calling the same function from within itself. If that left child has a left child of its own, we'll call the function on that child; if not, we'll move on to the right child.

For the above tree, here's a list of the function calls, in order:

CODE

Here's the same approach applied to an N-ary tree. It's very similar, but we just don't know the number of children, so we iterate through all of them:

CODE

export default ({ children }) => (
  <ArticleLayout meta={meta}>{children}</ArticleLayout>
);

;
