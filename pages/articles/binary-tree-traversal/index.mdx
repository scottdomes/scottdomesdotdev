import ArticleLayout from "components/articles/ArticleLayout";

export const meta = {
  title: "Mental models of tree traversal",
  date: "2021-04-30T22:40:32.169Z",
  description:
    "Binary trees, N-ary trees, preorder, postorder, inorder, all of it",
};

A common programming interview question is to ask you to traverse a tree. The tree might look something like this, and you're asked to go from node to node in a certain order.

tree

There are many variations on this question. It could be an n-ary tree or a binary tree (we'll discuss the difference). You could have to go through the nodes from top to bottom, or left to right. You could have to do preorder traversal, or postorder, or inorder... oh my.

Don't fret. While there are many variations, with varying levels of difficulty, this question gets a lot simpler when you have the right mental model of how traversal should work. So that's the goal of this article: to give you a clear picture of how to approach traversal questions.

Note that we'll try to approach this in a language-agnostic way; you should be able to apply this mental model to any programming language. For the purpose of examples, I'll alternate between Ruby and JavaScript.

# Types of trees

There are two main types of trees you'll encounter: binary and n-ary.

## Binary trees

Binary trees are composed of nodes that can have zero, one, or two children. No more than two children per node.

Here's a simple example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" hidePlayButton />

Another one:

<BinaryTree tree={[1, null, 2, 3, null, 4, 5, null, 6]} traversalMethod="preorder" hidePlayButton />

**Binary trees are made up of nodes with 0, 1, or 2 children.**

You may have also heard of binary _search_ trees, which are a subtype of binary trees, which specific rules for the order in which the numbers appear. You may see programming challenges involving binary search trees, but they're a little more complex, so we'll ignore them for now.

## N-ary trees

In a binary tree, each node is limited to two children. With an N-ary tree, you can have different maximum numbers of children, depending on _N_.

For example, a 3-ary tree (AKA ternary tree) means that each node can have a maximum of 3 children. A 156-ary tree means that each node can have up to 156 children.

Here's a N-ary tree where N is 4:

<BinaryTree tree={[1, null, 2, 3, 4, 5, null, 6, 7, null, 8]} treeType="nary" traversalMethod="preorder" hidePlayButton />

**N-ary trees are made up of nodes with up to N children.**

A binary tree is really just a specific type of N-ary tree: a 2-ary tree. But they're very common in interview questions, so it's good to talk about them. You may encounter challenges involving both binary and n-ary trees, but binary is the most popular type.

# Traversal

The basic definition of traversal is to visit each node in the tree once. How you do so, and in what order, depends on the question. Often, you'll be asked to keep track of each node you visited, in order, and give that as your solution.

There are several types of traversal. For this article, we're going to focus on the three most common: **preorder, inorder, and postorder.**

For each type, I'm going to explain how it works for a binary tree, and then show you the implementation. After we go through each type with the binary tree, I'll repeat the process with N-ary tree. Binary trees are easier to navigate and understand, so I think this will help you get the hang of it faster.

## Binary tree traversal

### Preorder traversal of a binary tree

Preorder traversal follows a simple process for visiting each node in the tree. Remember most challenges will ask you to return an array representing the order in which you visited the nodes; for each node we "visit", imagine pushing its value into an array, and then returning that.

Here's the process for preorder traversal:

1. Visit the first node (Node 1) in the tree, and push it into our output array
2. Visit the left child of Node 1 (Node 2), and push it into our output array
3. If Node 2 has a left child, we visit it, and push it into our output array; otherwise, we go to the right node of Node 1 (Node 3)

For each node, the process is: visit node, visit left child, visit right child.

This process is much easier to make sense of with a visualization. Let's start with a simple example:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="preorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="preorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="preorder"
/>

(The source code for these animations include the implementations of each type of traversal, in JavaScript, using the Queue method explained in the "Methods" section below.)

## Inorder traversal

In preorder traversal, we visit the node, then its children from left to right. With inorder traversal, we instead start with the left children first. Let's see this first with a binary tree, where it's simpler:

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="inorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="inorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="inorder"
/>

## Postorder traversal

Postorder is the reverse of preorder: in postorder, we visit all children before the parent.

<BinaryTree tree={[1, null, 2, 3]} traversalMethod="postorder" />

A more complex one:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7]}
  traversalMethod="postorder"
/>

And one more:

<BinaryTree
  tree={[1, null, 2, 3, null, 4, 5, null, 6, 7, null, 8, null, null, 9, 10]}
  traversalMethod="postorder"
/>

# N-ary tree

## N-ary preorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="preorder"
/>

## N-ary inorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="inorder"
/>

<BinaryTree
  tree={[1, null, 2, 3, 4, 5, null, 6, 7]}
  treeType="nary"
  traversalMethod="inorder"
/>

## N-ary postorder traversal

<BinaryTree
  tree={[1, null, 2, 3, 4, 5]}
  treeType="nary"
  traversalMethod="postorder"
/>

<BinaryTree
  tree={[1, null, 2, 3, 4, 5, null, 6, 7]}
  treeType="nary"
  traversalMethod="postorder"
/>

To implement this kind of traversal, the simplest approach is to use _recursion_.

Here's the code for applying this to a binary tree:

CODE

We print out the value of the node, and then visit its left child, calling the same function from within itself. If that left child has a left child of its own, we'll call the function on that child; if not, we'll move on to the right child.

For the above tree, here's a list of the function calls, in order:

CODE

Here's the same approach applied to an N-ary tree. It's very similar, but we just don't know the number of children, so we iterate through all of them:

CODE

export default ({ children }) => (
  <ArticleLayout meta={meta}>{children}</ArticleLayout>
);

;
