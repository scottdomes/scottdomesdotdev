import ArticleLayout from "components/articles/ArticleLayout";

export const meta = {
title: "The Rust Book",
date: "2021-04-23T22:40:32.169Z",
description: "Getting started with Rust"
}

*You can read the Rust book in full [here](https://doc.rust-lang.org/book/title-page.html)*.

# Getting Started

You can run `rustup doc` to access the documentation, even when offline.

Make a hello world via the following:

```rust
// main.rs
fn main() {
    println!("Hello, world!");
}
```

Then run: 

```bash
rustc main.rs
./main
```

You can run `rustfmt` from the command line to format files. [This](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust) is a VS Code extension for Rust projects, whereas [this one](https://marketplace.visualstudio.com/items?itemName=statiolake.vscode-rustfmt) works for single files.

*Macros* are invoked like `println!("Hello world!")` whereas functions are invoked without the exclamation mark. More on those later.

Rust is a compiled language, which means you compile a binary that anyone can then run (even without Rust installed). Running is thus two steps: compiling and running, vs how it is one step for dynamic languages like JavaScript, Ruby.

Cargo is Rust's build system and package manager. Its config file is written in TOML, which stands for Tom's Obvious, Minimal Language. Great name.

Best practice is to initialize a new Rust project via `cargo new my_project`.

To build a cargo project, run the following:

```bash
cargo build
./target/debug/my_project
```

Or you can just use:

```bash
cargo run
```

If you want to just see if it compiles correctly, run:

```bash
cargo check
```

To make an optimized release build, run:

```bash
cargo build --release
```

# Programming a guessing game

To import a package (in this case the `io` package from the standard library), use:

```rust
use std::io;
```

Certain parts of the standard library are always imported, and known as [the prelude](https://doc.rust-lang.org/std/prelude/index.html).

Rust variables are immutable by default (nice). To make one:

```rust
let foo = 5;
```

Make it mutable:

```rust
let mut foo = 5;
```

In the below code:

```rust
let mut string = String::new();
```

... we're calling the `new` associated function on the String type. An associated function belongs to a type, not an instance. AKA a static method.

Many functions can return a `Result` type. `Result` types are enums, with either the value of `Ok` or `Err`. 

If you want an `Err` Result to crash your program with a useful message, you can use `expect`. Here's an example of reading the user's CLI and showing a message on a failure:

```rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
```

(`&mut guess` is declaring a mutable reference. More on those later.)

Unhandled Results will result in a warning at compile time. (`expect` isn't really "handling" the error, per se, but it will suppress the warning; if you write `expect`, you want the program to crash when the `Result` is wrong.)

You can do string interpolation like so:

```rust
let x = 5;
let y = 10;

println!("x = {} and y = {}", x, y);
```

Rust calls packages "crates". Your project is a "binary crate"; it's meant to be executed. Packages you use in your project are "library crates"; they're meant to be used by other programs.

To add a dependency, modify `Cargo.toml` like so:

```toml
[dependencies]
rand = "0.5.5"
```

You can view crates via [Crates.io](https://crates.io/).

Your crate versions will stay the same thanks to `Cargo.lock`. To upgrade all your packages, run `cargo update`. Note that this will only upgrade minor version. `0.5.5` will become `0.5.6`, but never `0.6.0`; you have to manually upgrade to `0.6.0` via `Cargo.toml`.

Here's another example of importing and using a crate:

```rust
use rand::Rng;

let secret_number = rand::thread_rng().gen_range(1, 101);
```

We import the `Rng` trait of the `rand` crate; that must be in scope to allow us to use methods related to random number generators. We then call the `rng::thread_rng` function that gives us a random number generator that is local to the current thread. Then we call its `gen_range` method.

To see documentation for YOUR dependencies, run `cargo doc --open`. Pretty neat.


export default ({ children }) => (
  <ArticleLayout meta={meta}>{children}</ArticleLayout>
);